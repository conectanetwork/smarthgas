// ============================================
// FUNCI√ìN CORREGIDA PARA GR√ÅFICO DESLIZANTE
// ============================================

// Funci√≥n para actualizar gr√°fico con ventana deslizante autom√°tica
async function updateChartFromSupabase() {
    if (!supabaseClient || !consumptionChart) {
        console.log('‚ùå Cliente Supabase o gr√°fico no disponible');
        return;
    }
    
    try {
        console.log('üîç Actualizando gr√°fico con ventana deslizante...');
        
        // PASO 1: Generar 24 slots de las √∫ltimas 24 horas (SIEMPRE ACTUAL)
        const now = new Date();
        const labels = [];
        const netWeights = [];
        
        console.log(`‚è∞ Hora actual: ${now.toLocaleString('es-ES')}`);
        
        // Crear 24 slots de 1 hora cada uno (√∫ltimas 24 horas)
        for (let i = 23; i >= 0; i--) {
            const slotTime = new Date(now.getTime() - (i * 60 * 60 * 1000));
            labels.push(slotTime.toLocaleTimeString('es-ES', { 
                hour: '2-digit', 
                minute: '00' 
            }));
        }
        
        console.log('üìÖ Ventana de tiempo generada:', {
            desde: new Date(now.getTime() - (23 * 60 * 60 * 1000)).toLocaleString('es-ES'),
            hasta: now.toLocaleString('es-ES'),
            slots: labels.length
        });
        
        // PASO 2: Obtener datos de las √∫ltimas 24 horas desde Supabase
        const { data, error } = await supabaseClient
            .from('sensor_data')
            .select('weight, timestamp')
            .eq('device_id', 'ESP32_SMARTGAS_DEMO')
            .gte('timestamp', new Date(now.getTime() - 24 * 60 * 60 * 1000).toISOString())
            .order('timestamp', { ascending: true });

        if (error) {
            console.error('‚ùå Error obteniendo datos:', error);
            // En caso de error, llenar con ceros
            for (let i = 0; i < 24; i++) {
                netWeights.push(0);
            }
        } else {
            console.log(`üìä Datos obtenidos: ${data ? data.length : 0} registros`);
            
            // PASO 3: Obtener configuraci√≥n de pesos
            const emptyWeight = parseFloat(localStorage.getItem('emptyWeight')) || 5.0;
            const fullWeight = parseFloat(localStorage.getItem('fullWeight')) || 13.0;
            
            // PASO 4: Obtener el √∫ltimo dato disponible como fallback
            let lastAvailableWeight = 0;
            if (data && data.length > 0) {
                const lastData = data[data.length - 1];
                const totalWeight = parseFloat(lastData.weight) || 0;
                const { netWeight } = calculateNetWeightAndPercentage(totalWeight, emptyWeight, fullWeight);
                lastAvailableWeight = netWeight;
                console.log(`üìè √öltimo peso disponible: ${lastAvailableWeight.toFixed(2)}kg`);
            }
            
            // PASO 5: Llenar cada slot con datos reales o √∫ltimo disponible
            for (let i = 23; i >= 0; i--) {
                const slotTime = new Date(now.getTime() - (i * 60 * 60 * 1000));
                const slotStart = new Date(slotTime.getTime() - 30 * 60 * 1000); // -30 min
                const slotEnd = new Date(slotTime.getTime() + 30 * 60 * 1000);   // +30 min
                
                // Buscar datos en esta ventana de 1 hora (¬±30 min)
                let slotData = null;
                if (data && data.length > 0) {
                    for (const item of data) {
                        const itemTime = new Date(item.timestamp);
                        if (itemTime >= slotStart && itemTime <= slotEnd) {
                            slotData = item;
                            break; // Usar el primer dato encontrado en esta ventana
                        }
                    }
                }
                
                if (slotData) {
                    // Hay datos reales para esta hora
                    const totalWeight = parseFloat(slotData.weight) || 0;
                    const { netWeight } = calculateNetWeightAndPercentage(totalWeight, emptyWeight, fullWeight);
                    netWeights.push(netWeight);
                    console.log(`‚úÖ Slot ${23-i}: ${labels[23-i]} = ${netWeight.toFixed(2)}kg (dato real)`);
                } else {
                    // No hay datos, usar √∫ltimo disponible
                    netWeights.push(lastAvailableWeight);
                    console.log(`üîÑ Slot ${23-i}: ${labels[23-i]} = ${lastAvailableWeight.toFixed(2)}kg (√∫ltimo disponible)`);
                }
            }
        }
        
        // PASO 6: Actualizar gr√°fico
        consumptionChart.data.labels = labels;
        consumptionChart.data.datasets[0].data = netWeights;
        consumptionChart.update();
        
        console.log('‚úÖ Gr√°fico actualizado con ventana deslizante');
        console.log('üìà Rango de datos:', {
            min: Math.min(...netWeights).toFixed(2) + 'kg',
            max: Math.max(...netWeights).toFixed(2) + 'kg',
            promedio: (netWeights.reduce((a, b) => a + b, 0) / netWeights.length).toFixed(2) + 'kg'
        });
        
    } catch (error) {
        console.error('‚ùå Error cr√≠tico en updateChartFromSupabase:', error);
        
        // Gr√°fico de emergencia con horas actuales
        const now = new Date();
        const emergencyLabels = [];
        const emergencyData = [];
        
        for (let i = 23; i >= 0; i--) {
            const time = new Date(now.getTime() - (i * 60 * 60 * 1000));
            emergencyLabels.push(time.toLocaleTimeString('es-ES', { 
                hour: '2-digit', 
                minute: '00' 
            }));
            emergencyData.push(0);
        }
        
        consumptionChart.data.labels = emergencyLabels;
        consumptionChart.data.datasets[0].data = emergencyData;
        consumptionChart.update();
        
        console.log('üö® Gr√°fico de emergencia cargado');
    }
}

// ============================================
// INICIALIZACI√ìN CON ACTUALIZACI√ìN HORARIA
// ============================================

// Funci√≥n para calcular milisegundos hasta la pr√≥xima hora
function millisecondsUntilNextHour() {
    const now = new Date();
    const nextHour = new Date(now);
    nextHour.setHours(now.getHours() + 1, 0, 0, 0); // Pr√≥xima hora en punto
    return nextHour.getTime() - now.getTime();
}

// Funci√≥n para inicializar actualizaci√≥n horaria autom√°tica
function initHourlyChartUpdate() {
    console.log('‚è∞ Configurando actualizaci√≥n horaria autom√°tica...');
    
    // Primera actualizaci√≥n inmediata
    setTimeout(updateChartFromSupabase, 3000);
    
    // Programar primera actualizaci√≥n en la pr√≥xima hora
    const msUntilNextHour = millisecondsUntilNextHour();
    console.log(`‚è∞ Pr√≥xima actualizaci√≥n autom√°tica en: ${Math.round(msUntilNextHour / 1000 / 60)} minutos`);
    
    setTimeout(() => {
        console.log('üîÑ Actualizaci√≥n horaria autom√°tica ejecutada');
        updateChartFromSupabase();
        
        // Despu√©s de la primera, actualizar cada hora exacta
        setInterval(() => {
            console.log('üîÑ Actualizaci√≥n horaria autom√°tica ejecutada');
            updateChartFromSupabase();
        }, 60 * 60 * 1000); // Cada hora
        
    }, msUntilNextHour);
    
    // Tambi√©n actualizar cada 10 minutos para datos recientes
    setInterval(() => {
        console.log('üîÑ Actualizaci√≥n peri√≥dica (10 min)');
        updateChartFromSupabase();
    }, 10 * 60 * 1000);
    
    console.log('‚úÖ Actualizaci√≥n horaria configurada');
}

// ============================================
// MODIFICACI√ìN EN LA INICIALIZACI√ìN
// ============================================

// En lugar de usar setTimeout e setInterval normales, usar:
// initHourlyChartUpdate(); // En lugar de las actualizaciones anteriores
